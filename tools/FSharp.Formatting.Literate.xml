<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Formatting.Literate</name></assembly>
<members>
<member name="T:FSharp.Collections.Tree`1">
<summary>
 Represents a tree with nodes containing values an a list of children

</summary>
</member>
<member name="M:FSharp.Collections.Tree.ofIndentedList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Turns a list of items with an indentation specified by an integer
 into a tree where indented items are children.
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeDeeperThan``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes elements that are deeper (children) and turns them into nodes
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeAtLevel``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes all elements at the specified level and turns them into nodes
</summary>
</member>
<member name="M:FSharp.Collections.List.nestUnderLastMatching``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A function that nests items of the input sequence
 that do not match a specified predicate under the
 last item that matches the predicate.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilEquals``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions the input list into two parts - the break is added
 at a point where the list starts with the specified sub-list.
</summary>
</member>
<member name="M:FSharp.Collections.List.startsWith``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Tests whether a list starts with the elements of another
 list (specified as the first parameter)
</summary>
</member>
<member name="M:FSharp.Collections.List.iterInterleaved``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Iterates over the elements of the list and calls the first function for
 every element. Between each two elements, the second function is called.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntil``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhileLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the specified predicate
 returns true) and a rest of the list. The predicate gets the entire
 tail of the list and can perform lookahead.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the
 specified predicate returns true) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Patterns.|Command|_|``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup in a dictionary
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommand|_|(System.String)">
<summary>
 Utility for parsing commands - this deals with a single command.
 The key of the command should be identifier with just
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommands|_|(System.String)">
<summary>
 Utility for parsing commands. Commands can be used in different places. We
 recognize `key1=value, key2=value` and also `key1:value, key2:value`
 The key of the command should be identifier with just
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|Let|``2(``0,``1)">
<summary>
 Parameterized pattern that assigns the specified value to the
 first component of a tuple. Usage:

    match str with
    | Let 1 (n, &quot;one&quot;) | Let 2 (n, &quot;two&quot;) -&gt; n

</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimParagraphLines|(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Formatting.Markdown.MarkdownRange}})">
<summary>
 Trims all lines of the current paragraph
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimBlankStart|(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Formatting.Markdown.MarkdownRange}})">
<summary>
 Removes whitespace lines from the beginning of the list
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeCodeBlock|_|(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Formatting.Markdown.MarkdownRange}})">
<summary>
 Matches when there are some lines at the beginning that are
 either empty (or whitespace) or start with at least 4 spaces (a tab counts as 4 spaces here).
 Returns all such lines from the beginning until a different line and
 the number of spaces the first line started with.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeStartingWithOrBlank|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Matches when there are some lines at the beginning that are
 either empty (or whitespace) or start with the specified string.
 Returns all such lines from the beginning until a different line.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimBlank|``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,``0}})">
<summary>
 Removes blank lines from the start and the end of a list
</summary>
</member>
<member name="M:FSharp.Patterns.List.|AsString|(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Returns a list of characters as a string.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|BracketDelimited|_|(System.Char,System.Char,Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Matches a list if it starts with a bracketed list. Nested brackets
 are skipped (by counting opening and closing brackets) and can be
 escaped using the &apos;\&apos; symbol.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|Delimited|_|``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiter. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|StartsWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list. Returns the list.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|DelimitedWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiters. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|EqualsRepeated|_|(System.String,FSharp.Formatting.Markdown.MarkdownRange,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string consists of some number of
 complete repetitions of a specified sub-string.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithWrapped|_|(System.String,System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with a sub-string wrapped using the
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithRepeated|_|(System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with a non-zero number of complete
 repetitions of the specified parameter (and returns the number
 of repetitions, together with the rest of the string)

    let (StartsWithRepeated &quot;/\&quot; (2, &quot; abc&quot;)) = &quot;/\/\ abc&quot;

</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with the given value and ends
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsAndEndsWith|_|(System.String,System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with the given value and ends
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithNTimesTrimIgnoreStartWhitespace|_|(System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string (ignoring whitespace at the start)
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithTrim|_|(System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWith|_|(System.String,System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithAny|_|(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string starts with any of the specified sub-strings
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimStartAndCount|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Returns a string trimmed from the start together with
 the number of skipped whitespace characters
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimEndUsing|(System.Collections.Generic.IEnumerable{System.Char},System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Returns a string trimmed from the end using characters given as a parameter
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimStart|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Returns a string trimmed from the start
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimEnd|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Returns a string trimmed from the end
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimBoth|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|Unindented|_|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string does starts with non-whitespace
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|WhiteSpace|_|(System.String,FSharp.Formatting.Markdown.MarkdownRange)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="M:FSharp.Patterns.String.removeSpaces(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Given a list of lines indented with certan number of whitespace
 characters (spaces), remove the spaces from the beginning of each line
 and return the string as a list of lines
</summary>
</member>
<member name="M:FSharp.Patterns.String.|SkipSingleLine|(System.String)">
<summary>
 Ignores everything until a end-line character is detected, returns the remaining string.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithWrapped|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with a sub-string wrapped using the
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWith|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithTrim|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWith|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimBoth|(System.String)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|WhiteSpace|_|(System.String)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.SourceFile">
<summary>
 Location where the file was loaded from
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.Source">
<summary>
 Original document source code
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.RootInputFolder">
<summary>
 Root for computing relative paths
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.Paragraphs">
<summary>
 Returns a list of paragraphs in the document
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.MarkdownDocument">
<summary>
 Return as markdown document, throwing away additional stuff
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.FormattedTips">
<summary>
 Formatted tool tips
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.Diagnostics">
<summary>
 Errors
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocument.DefinedLinks">
<summary>
 Returns a dictionary containing explicitly defined links
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.LiterateDocument.With(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.Markdown.MarkdownParagraph}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}}},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.LiterateSource},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.CodeFormat.SourceError[]})">
<summary>
 Clone the document and change some of its properties
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateDocument">
<summary>
 Representation of a literate document - the representation of Paragraphs
 uses an F# discriminated union type and so is best used from F#.
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateSource.Script">
<summary>
 A parsed F# script file consisting of snippets.
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateSource.Markdown">
<summary>
 A markdown source
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateSource">
<summary>
 Represents the source of a literate document.
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.RawBlock">
<summary>
 Block simply emitted without any formatting equivalent to &lt;pre&gt; tag in html
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.LanguageTaggedCode">
<summary>
 Ordinary formatted code snippet in non-F# language (tagged with language code)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.LiterateCode">
<summary>
 Emebdded literate code snippet. Consists of source lines and options
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.ValueReference">
<summary>
 (*** include-value:foo ***) - Include the formatting of a specified value here
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.ItRawReference">
<summary>
 (*** include-it-raw ***) - Include &quot;it&quot; value from the subsequent snippet here as raw text (Not formatted as fsi)
 (*** include-it-raw:foo ***) - Include &quot;it&quot; value from a named snippet as raw text (Not formatted as fsi)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.ItValueReference">
<summary>
 (*** include-it ***) - Include &quot;it&quot; value from the subsequent snippet here
 (*** include-it:foo ***) - Include &quot;it&quot; value from a named snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.OutputReference">
<summary>
 (*** include-fsi-output ***) - Include F# Interactive output from previous snippet
 (*** include-fsi-output:foo ***) - Include F# Interactive from a named snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.FsiMergedOutputReference">
<summary>
 (*** include-fsi-merged-output ***) - Include output from previous snippet
 (*** include-fsi-merged-output:foo ***) - Include output from a named snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.FsiOutputReference">
<summary>
 (*** include-fsi-output ***) - Include output from previous snippet
 (*** include-fsi-output:foo ***) - Include output from a named snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph.CodeReference">
<summary>
 (*** include:foo ***) - Include formatted snippet from other part of the document here
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraph">
 <summary>
 Extends <c>MarkdownParagrap</c> using the <c>MarkdownEmbedParagraphs</c> case with
 additional kinds of paragraphs that can appear in literate F# scripts
 (such as various special commands to embed output of a snippet etc.)
 </summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateCodeOptions.Visibility">
<summary>
 Specifies the visibility of the snippet in the generated HTML
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateCodeOptions.ExecutionCount">
<summary>
 Indiciates the execution sequence number of the cell if it has been evaluated
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateCodeOptions.OutputName">
<summary>
 Specifies the name of the output produced by this snippet
 Use the (*** define-output:foo ***) command to set this value
 Other outputs are named cell1, cell2 etc.
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateCodeOptions.Evaluate">
 <summary>
 Specifies whether the snippet is evalauted while processing
 Use (*** do-not-eval ***) command to set this to <c>false</c>
 </summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateCodeOptions">
 <summary>
 Additional properties of a literate code snippet, embedded in a
 <c>LiterateParagraph.LiterateCode</c>. The properties specify how should
 a snippet be evaluated and formatted.
 </summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateParagraphOptions.Condition">
<summary>
 Specifies a conditional for inclusion of the snippet paragraph
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateParagraphOptions">
<summary>
 Specifies the options for a literate paragraph
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateCodeVisibility.NamedCode">
<summary>
 Named snippet with captured output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateCodeVisibility.HiddenCode">
<summary>
 Hidden snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateCodeVisibility.VisibleCode">
<summary>
 Ordinary visible code
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateCodeVisibility">
<summary>
 Specifies visibility of a code snippet.
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.ConditionalDefines">
<summary>
 Conditional defines for the processing
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.CodeReferenceResolver">
<summary>
 Helper to resolve `cref:T:TypeName` references in markdown
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.MarkdownDirectLinkResolver">
<summary>
 Helper to resolve URL referenecs in markdown, e.g. &apos;index.md&apos; --&gt; &apos;index.html&apos; when doing HTML output
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.OutputKind">
<summary>
 The output format
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.GenerateHeaderAnchors">
<summary>
 Auto-generate anchors for headers
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.GenerateLineNumbers">
<summary>
 Generate line numbers for F# snippets?
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.Substitutions">
<summary>
 Additional substitutions to be made in the template file
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateProcessingContext.Prefix">
<summary>
 Short prefix code added to all HTML &apos;id&apos; elements
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateProcessingContext">
<summary>
 Specifies a context that is passed to functions that generate the output
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.OutputKind">
<summary>
 The kind of output generated
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.OutputPath">
<summary>
 The relative output path
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.Index">
<summary>
 The index in the front matter (Determines the order of files within a category)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.CategoryIndex">
<summary>
 The category index in the front matter (determines the order of categories)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.Category">
<summary>
 The category in the front matter
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.IndexText">
<summary>
 The text for search index generation (empty for notebooks and latex)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.Substitutions">
<summary>
 The replacement paramaters
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.LiterateDocModel.Title">
<summary>
 The extracted title of the document (first h1 header if not in front matter)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.LiterateDocModel">
<summary>
 Defines the output of processing a literate doc
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind.Markdown">
<summary>
 Requests Markdown output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind.Fsx">
<summary>
 Requests F# Script output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind.Pynb">
<summary>
 Requests Notebook output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind.Latex">
<summary>
 Requests LaTeX output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind.Html">
<summary>
 Requests HTML output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.OutputKind">
<summary>
 Defines the possible output types from literate script (HTML, Latex, Pynb)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.CompilerContext.OnError">
<summary>
 Reporting errors
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.CompilerContext.ConditionalDefines">
<summary>
 Defined symbols for the F# compiler
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.CompilerContext.CompilerOptions">
<summary>
 Command line options for the F# compiler
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.CompilerContext.Evaluator">
<summary>
 F# interactive evaluator
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.CompilerContext">
<summary>
 Specifies a context that is passed to functions
 that need to use the F# compiler
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.ParseScript.ParseAndCheckScriptFile(System.String,System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Parse script file with specified name and content
 and return LiterateDocument with the content
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.ParseScript">
<summary>
 Turns the content of fsx file into LiterateDocument that contains
 formatted F# snippets and parsed Markdown document. Handles commands such
 as hide, define and include.
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.WriteLatex(FSharp.Formatting.Literate.LiterateDocument,System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}})">
<summary>
 Write the literate document as Latex without using a template
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.WriteHtml(FSharp.Formatting.Literate.LiterateDocument,System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Formatting.CodeFormat.TokenKind,System.String}})">
<summary>
 Write the literate document as HTML without using a template
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ToPynb(FSharp.Formatting.Literate.LiterateDocument,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}})">
<summary>
 Formate the literate document as an iPython notebook
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ToLatex(FSharp.Formatting.Literate.LiterateDocument,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}})">
<summary>
 Format the literate document as Latex without using a template
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ToHtml(FSharp.Formatting.Literate.LiterateDocument,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Formatting.CodeFormat.TokenKind,System.String}})">
<summary>
 Format the literate document as HTML without using a template
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ToFsx(FSharp.Formatting.Literate.LiterateDocument,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}})">
<summary>
 Formate the literate document as an .fsx script
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseScriptString(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Markdown.MarkdownParseOptions},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
<summary>
 Parse string as F# Script to LiterateDocument
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseMarkdownString(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Markdown.MarkdownParseOptions},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
 <summary>
  Parse string as a markdown document
 </summary>
 <param name="content"></param>
 <param name="path">optional file path for debugging purposes</param>
 <param name="fscOptions"></param>
 <param name="definedSymbols"></param>
 <param name="references"></param>
 <param name="fsiEvaluator"></param>
 <param name="parseOptions">Defaults to MarkdownParseOptions.AllowYamlFrontMatter</param>
 <param name="rootInputFolder"></param>
 <param name="onError"></param>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseMarkdownFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Markdown.MarkdownParseOptions},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
 <summary>
  Parse Markdown document to LiterateDocument
 </summary>
 <param name="path"></param>
 <param name="fscOptions"></param>
 <param name="definedSymbols"></param>
 <param name="references"></param>
 <param name="fsiEvaluator"></param>
 <param name="parseOptions">Defaults to MarkdownParseOptions.AllowYamlFrontMatter</param>
 <param name="rootInputFolder"></param>
 <param name="onError"></param>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseAndTransformScriptFile(System.String,System.String,FSharp.Formatting.Literate.OutputKind,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
<summary>
 Parse and transform an F# script file
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseAndTransformMarkdownFile(System.String,System.String,FSharp.Formatting.Literate.OutputKind,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}},FSharp.Formatting.Markdown.MarkdownParseOptions,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
<summary>
 Parse and transform a markdown document
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ParseAndCheckScriptFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Markdown.MarkdownParseOptions},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
<summary>
 Parse F# Script file to LiterateDocument
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ConvertScriptFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.Evaluation.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
 <summary>Convert a script file into HTML or another output kind</summary>
 <example>
   <code>
     Literate.ConvertScriptFile("script.fsx", template)
   </code>
 </example>
</member>
<member name="M:FSharp.Formatting.Literate.Literate.ConvertMarkdownFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,System.String}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}})">
<summary>
 Convert a markdown file into HTML or another output kind
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Literate">
 <summary>
 This type provides three simple methods for calling the literate programming tool.
 The <c>ConvertMarkdownFile</c> and <c>ConvertScriptFile</c> methods process a single Markdown document
 and F# script, respectively. The <c>ConvertDirectory</c> method handles an entire directory tree
 (looking for <c>*.fsx</c> and <c>*.md</c> files).
 </summary>

 <namespacedoc>
   <summary>Functionality to support literate programming for F# scripts</summary>
 </namespacedoc>
</member>
<member name="T:FSharp.Formatting.Literate.MarkdownPatterns">
 <summary>
 Provides active patterns for extracting <c>LiterateParagraph</c> values from
 Markdown documents.
 </summary>
</member>
<member name="F:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedFsiObj@">
<summary>
 Temporarily holds the object value injected into the F# evaluation session
</summary>
</member>
<member name="F:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddHtmlPrinter@">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="F:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrinter@">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="F:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrintTransformer@">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="F:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.valueTransformations">
<summary>
 Registered transformations for pretty printing values
 (the default formats value as a string and emits single CodeBlock)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedFsiObj(System.Object)">
<summary>
 Temporarily holds the object value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrinter(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{System.Object,System.String},System.Type},Microsoft.FSharp.Core.Unit})">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrintTransformer(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object},System.Type},Microsoft.FSharp.Core.Unit})">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddHtmlPrinter(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Tuple{System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},System.String}},System.Type},Microsoft.FSharp.Core.Unit})">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedFsiObj">
<summary>
 Temporarily holds the object value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrinter">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddPrintTransformer">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.InjectedAddHtmlPrinter">
<summary>
 Temporarily holds the function value injected into the F# evaluation session
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.EvaluationFailed">
<summary>
 This event is fired whenever an evaluation of an expression fails
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Evaluation.FsiEvaluator.RegisterTransformation(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Object,System.Type,System.Int32},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.Markdown.MarkdownParagraph}}})">
<summary>
 Register a function that formats (some) values that are produced by the evaluator.
 The specified function should return &apos;Some&apos; when it knows how to format a value
 and it should return formatted
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEvaluator">
<summary>
 A wrapper for F# interactive service that is used to evaluate inline snippets
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Evaluation.FsiEvaluatorConfig.CreateNoOpFsiObject">
<summary>
 Creates a dummy fsi object that does not affect the behaviour of F# Interactive
 (and simply ignores all operations that are done on it). You can use this to
 e.g. disable registered printers that would open new windows etc.
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEvaluatorConfig">
<summary>
 Provides configuration options for the FsiEvaluator
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.NoOpFsiObject">
<summary>
 Implements a simple &apos;fsi&apos; object to be passed to the FSI evaluator
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.NoOpFsiEventLoop">
<summary>
 Represents a simple (fake) event loop for the &apos;fsi&apos; object
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Evaluation.IFsiEvaluator.Format(FSharp.Formatting.Literate.Evaluation.IFsiEvaluationResult,FSharp.Formatting.Literate.Evaluation.FsiEmbedKind,System.Int32)">
<summary>
 Called to format some part of evaluation result generated by FSI
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Evaluation.IFsiEvaluator.Evaluate(System.String,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Called to evaluate a snippet
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.IFsiEvaluator">
<summary>
 Represents an evaluator for F# snippets embedded in code
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEvaluationFailedInfo">
<summary>
 Record that is reported by the EvaluationFailed event when something
 goes wrong during evalutaiton of an expression
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEvaluationResult">
<summary>
 Represents the result of evaluating an F# snippet. This contains
 the generated console output together with a result and its static type.
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.IFsiEvaluationResult">
<summary>
 An interface that represents FSI evaluation result
 (we make this abstract so that evaluators can store other info)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.Value">
<summary>
 A specific value
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.ItRaw">
<summary>
 The &apos;it&apos; value as raw text
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.ItValue">
<summary>
 The &apos;it&apos; value
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.ConsoleOutput">
<summary>
 The stdout from this part of the execution (not including FSI output)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.FsiMergedOutput">
<summary>
 The combined FSI output and console output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind.FsiOutput">
<summary>
 The FSI output
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Evaluation.FsiEmbedKind">
 <summary>
   Represents a kind of thing that can be embedded
 </summary>
 <namespacedoc>
   <summary>Functionality to support literate evaluation for F# scripts</summary>
 </namespacedoc>
</member>
<member name="M:FSharp.Formatting.Literate.CodeBlockUtils.parseScriptFile(Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line})">
<summary>
 Parse F# script file into a sequence of snippets, comments and commands
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.CodeBlockUtils.collectSnippet(Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line},Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line})">
<summary>
 Collecting a block of F# snippet
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.CodeBlockUtils.collectComment(System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line})">
<summary>
 Waiting for the end of a comment
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.CodeBlockUtils.|ConcatenatedComments|_|(FSharp.Formatting.CodeFormat.Line)">
<summary>
 Succeeds when a line (list of tokens) contains only Comment
 tokens and returns the text from the comment as a string
 (Comment may also be followed by Whitespace that is skipped)
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.CodeBlockUtils.trimBlanksAndReverse(System.Collections.Generic.IEnumerable{FSharp.Formatting.CodeFormat.Line})">
<summary>
 Trim blank lines from both ends of a lines list &amp; reverse it (we accumulate
 lines &amp; we want to remove all blanks before returning BlockSnippet)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.CodeBlockUtils">
<summary>
 Parsing of F# Script files with Markdown commands. Given a parsed script file, we
 split it into a sequence of comments, snippets and commands (comment starts with
 &lt;c&gt;(**&lt;/c&gt; and ending with &lt;c&gt;*)&lt;/c&gt; are translated to Markdown, snippet is all other F# code
 and command looks like &lt;c&gt;(*** key1:value, key2:value ***)&lt;/c&gt; (and should be single line).
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.ParseMarkdown.parseMarkdown(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.Formatting.Markdown.MarkdownParseOptions})">
<summary>
 Parse the specified Markdown document and return it
 as LiterateDocument (without processing code snippets)
</summary>
</member>
<member name="T:FSharp.Formatting.Literate.Transformations.EvalKey">
<summary>
 Represents key in a dictionary with evaluation results
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceLiterateParagraphs(FSharp.Formatting.Literate.LiterateProcessingContext,FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements with ordinary HTML/Latex
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceLiterateParagraph(FSharp.Formatting.Literate.LiterateProcessingContext,System.Collections.Generic.IDictionary{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line},System.String},FSharp.Formatting.Markdown.MarkdownParagraph},FSharp.Formatting.Markdown.MarkdownParagraph)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements recursively using the given lookup dictionary
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceHtmlTaggedCode(FSharp.Formatting.Literate.LiterateProcessingContext,System.String,System.String)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements recursively using the given lookup dictionary
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.collectLiterateCode(FSharp.Formatting.Markdown.MarkdownParagraph)">
<summary>
 Collect all code snippets in the document (so that we can format all of them)
 The resulting dictionary has Choice as the key, so that we can distinguish
 between moved snippets and ordinary snippets
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.evaluateCodeSnippets(FSharp.Formatting.Literate.CompilerContext,FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Transform the specified literate document &amp; evaluate all F# snippets
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceEvaluations(FSharp.Formatting.Literate.CompilerContext,Microsoft.FSharp.Collections.FSharpMap{FSharp.Formatting.Literate.Transformations.EvalKey,System.Tuple{FSharp.Formatting.Literate.Evaluation.IFsiEvaluationResult,System.Int32}},FSharp.Formatting.Markdown.MarkdownParagraph)">
<summary>
 Replace evaluation references with the results
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.evalAllSnippets(FSharp.Formatting.Literate.CompilerContext,FSharp.Formatting.Literate.Evaluation.IFsiEvaluator,FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Given an evaluator and document, evaluate all code snippets and return a map with
 their results - the key is ValueRef(name) for all value references and
 OutputRef(name) for all references to the snippet console output
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.evalBlocks(FSharp.Formatting.Literate.CompilerContext,FSharp.Formatting.Literate.Evaluation.IFsiEvaluator,Microsoft.FSharp.Core.FSharpRef{System.Int32},System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Literate.Transformations.EvalKey,System.Tuple{FSharp.Formatting.Literate.Evaluation.IFsiEvaluationResult,System.Int32}}},Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.Markdown.MarkdownParagraph})">
<summary>
 Evaluate all the snippets in a literate document, returning the results.
 The result is a map of string * bool to FsiEvaluationResult. The bool indicates
 whether the result is a top level variable (i.e. include-value) or a reference to
 some output (i.e. define-output and include-output). This just to put each of those
 names in a separate scope.
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.unparse(Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line})">
<summary>
 Unparse a Line list to a string - for evaluation by fsi.
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.generateReferences(Microsoft.FSharp.Core.FSharpOption{System.Boolean},FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Turn all indirect links into a references
 and add paragraph to the document
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.generateReferenceParagraphs``1(System.Collections.Generic.IDictionary{``0,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given all links defined in the Markdown document and a list of all links
 that are accessed somewhere from the document, generate References paragraph
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceReferences(System.Collections.Generic.IDictionary{System.String,System.Int32})">
<summary>
 Given Markdown document, add a number using the given index to all indirect
 references. For example, [article][ref] becomes [article][ref] [1](#rfxyz)
</summary>
</member>
<member name="P:FSharp.Formatting.Literate.Transformations.collectReferences">
<summary>
 Given Markdown document, get the keys of all IndirectLinks
 (to be used when generating paragraph with all references)
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.formatCodeSnippets(System.String,FSharp.Formatting.Literate.CompilerContext,FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Walk over literate document and replace F# code snippets with
 their formatted representation (of LiterateParagraph type)

 Note: this processes snipppets within markdown, not snippets coming from .fsx
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.replaceCodeSnippets(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.Formatting.CodeFormat.Line}},FSharp.Formatting.Markdown.MarkdownParagraph)">
<summary>
 Replace CodeBlock elements with referenced code snippets.
 (The dictionary argument is a map from original code snippets to formatted HTML snippets.)

 Note: this processes snipppets within markdown, not snippets coming from .fsx
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Transformations.collectCodeSnippets(FSharp.Formatting.Markdown.MarkdownParagraph)">
<summary>
 Iterate over Markdown document and extract all F# code snippets that we want
 to colorize. We skip snippets that specify non-fsharp langauge e.g. [lang=csharp].

 Note: this processes snipppets within markdown, not snippets coming from .fsx
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Formatting.getIndexText(FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Given literate document, get the text for indexing for search
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Formatting.getSourceDocument(FSharp.Formatting.Literate.LiterateDocument)">
<summary>
 Given literate document, get a new MarkdownDocument that represents the
 entire source code of the specified document (with possible fsx formatting)
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Formatting.findHeadings(System.Collections.Generic.IEnumerable{FSharp.Formatting.Markdown.MarkdownParagraph},System.Boolean,FSharp.Formatting.Literate.OutputKind)">
<summary>
 Try find first-level heading in the paragraph collection
</summary>
</member>
<member name="M:FSharp.Formatting.Literate.Formatting.format(FSharp.Formatting.Markdown.MarkdownDocument,System.Boolean,FSharp.Formatting.Literate.OutputKind,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Formatting.Templating.ParamKey,System.String}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}})">
<summary>
 Format document with the specified output kind
</summary>
</member>
</members>
</doc>
